## 什么是高阶组件

高阶组件就是一个函数，传给它一个组件，它返回一个新的组件。

    const NewComponent = higherOrderComponent(OldComponent)

重要的事情再重复一次，高阶组件是一个函数（而不是组件），它接受一个组件作为参数，返回一个新的组件。这个新的组件会使用你传给它的组件作为子组件，我们看看一个很简单的高阶组件：


    export default (WrappedComponent) => {
      class NewComponent extends Component {
      //可以做很多自定义逻辑
	    render() {
	      return <WrappedComponent />
	    }
      }
      return NewComponent
    }

现在看来好像什么用都没有，它就是简单的构建了一个新的组件类NewComponent，然后把传进去的WrappedComponent渲染出来。但是我们可以给NewComponent做一些数据启动工作:

    export default (WrappedComponent, name) => {
      class NewComponent extends Component {
      //可以做很多自定义逻辑
	    construnctor () {
	      super()
	      this.state = { data: null}
	    }
	    
	    componentWillMount () {
	      let data = localStorage.getItem(name)
	      this.setState({data})
	    }
	    
	    render() {
	      return <WrappedComponent data={this.state.data} />
	    	}
	     }
      return NewComponent
    }

现在NewComponent会根据第二个参数name在挂载阶段从LocalStorage加载数据，并且setState到自己的state.data中，而渲染的时候将state.data通过props.data传给WrappedComponent。

**这个高阶组件有什么用呢？**假设上门的代码是在src/wrapWithLoadData.js文件中的，我们可以在别的地方这个用它：

    import wrapWithLoadData from './wrapWithLoadData'
    
    class InputWithUserName extends Component {
      render() {
        return <input value={this.props.data} />
      }
    }
    
    InputWithUserName = wrapWithLoadData(InputWithUserName, 'username')
    export default InputWithUserName 

加入InputWithUserName的功能需求是挂载的时候从LocalStorage里面加载`username`字段作为`<input />`的value值，现在有了wrapWithLoadData，我们可以很容易做到这件事情。

只需要定义一个非常简单的`InputWithUserName`，它会把`props.data`作为`<input />`的`value`值。然后把这个组件和`'username'` 传给`wrapWithLoadData`，`wrapWithLoadData`会返回一个新的组件，我们用这个组件覆盖原来的`InputWithUserName`，然后再导出去模块。